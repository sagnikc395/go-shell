package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

// Ensures gofmt doesn't remove the "fmt" import in stage 1 (feel free to remove this!)
var _ = fmt.Print

func getExecutablePath() string {
	result := ""
	ex,err := os.Executable()
	if err != nil {
		log.Fatal(err)
	}
	dir := path.Dir(ex)
	result += dir
	return result 
}


func main() {
	runShell := true
	for runShell {
		fmt.Print("$ ")
		cmd, err := bufio.NewReader(os.Stdin).ReadString('\n')
		if err != nil {
			panic(err)
		}

		command := strings.Fields(cmd)
		cmd = command[0]
		args := command[1:]

		switch cmd {
		case "exit":
			runShell = false
		case "echo":
			for _, v := range args {
				fmt.Printf("%v ", v)
			}
			fmt.Printf("\n")
		case "type":
			type_check := args[0]
			if type_check == "echo" || type_check == "exit" || type_check == "type" {
				fmt.Printf("%v is a shell builtin\n", type_check)
			}
			// check it in PATH
			// 1.Go through every directory in PATH. For each directory
			// 2. check if a file with the command name exists
			// 3. check if the file has execute permissions
			// 4. if the file exists and has execute permissions, print <command> is <full_path> and stop.
			// 5. If the file exists but lacks execute permissions, skip it and continue to the next directory.
			getExecutablePath() 

			else {
				fmt.Printf("%v: not found\n", type_check)
			}

		default:
			fmt.Printf(cmd + ": command not found\n")
		}

	}
}
